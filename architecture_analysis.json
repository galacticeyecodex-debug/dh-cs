{
  "issues": [
    {
      "issue_name": "Issue 1: Monolithic Character Store (826 lines)",
      "severity": "HIGH",
      "root_cause": "The `useCharacterStore` mixes multiple distinct concerns into a single Zustand store: (1) User authentication/profiles, (2) Character data fetching and hydration, (3) UI state management (activeTab, dice overlay), (4) Vital/stat modifications with optimistic updates, (5) Inventory/equipment management, (6) Game mechanics calculations (armor scoring, damage thresholds, derived stats), (7) Database persistence with error handling. The store violates Single Responsibility Principle by combining data layer, business logic, and UI orchestration.",
      "impact": {
        "maintainability": "CRITICAL - Difficult to locate specific functionality. Changes to one concern risk breaking others. New developers have high cognitive load.",
        "testability": "CRITICAL - Cannot unit test individual concerns in isolation. Complex dependencies between logic layers prevent mocking.",
        "reusability": "HIGH - Game logic (armor calculations, stat recalculations) is trapped in store and cannot be used elsewhere (e.g., NPCs, character generators, validation).",
        "performance": "MEDIUM - Entire store re-renders on any state change. Fine-grained reactivity is impossible without splitting.",
        "team_velocity": "HIGH - Code reviews are harder. Feature additions require understanding full store context. Merge conflicts likely on shared logic."
      },
      "reproduction_steps": [
        "Open store/character-store.ts",
        "Try to understand the flow of a single feature (e.g., updating armor)",
        "Trace: updateVitals -> armor_slots change -> DB update -> recalculateDerivedStats -> fetches inventory -> calculates armor_score -> updates DB again",
        "Note how armor logic appears in recalculateDerivedStats (lines 290-429), common-vitals-display.tsx (lines 33-48), and utils.ts (getSystemModifiers)",
        "Observe that adding a new armor feature requires changes to multiple places across different files",
        "Try to test armor calculation in isolation - impossible without mocking entire store and Supabase"
      ],
      "recommended_fix": {
        "strategy": "Split into 5 Zustand stores following domain-driven design",
        "slices": [
          {
            "name": "authStore",
            "domain": "Authentication & Profile Management",
            "functions": [
              "fetchUser()",
              "setUser()",
              "state: { user, isLoading }"
            ],
            "rationale": "Auth is a separate concern from character data. Can be used independently for profile management."
          },
          {
            "name": "characterStore",
            "domain": "Character Data & Persistence",
            "functions": [
              "fetchCharacter(userId, characterId?)",
              "switchCharacter(characterId)",
              "setCharacter()",
              "state: { character, isLoading }"
            ],
            "rationale": "Core data layer. Responsible only for loading and setting character data from DB. No game logic."
          },
          {
            "name": "gameLogicStore",
            "domain": "Game Mechanics & Calculations",
            "functions": [
              "recalculateDerivedStats()",
              "calculateArmorScore(inventory, character)",
              "calculateDamageThresholds(level, armor)",
              "calculateMaxHP(classData, modifiers)",
              "calculateMaxStress(modifiers)",
              "Pure functions: armor calculation, threshold calculation, etc."
            ],
            "rationale": "Encapsulates all game rule mechanics. Can be tested independently. Can be reused for NPCs, character builders, validators.",
            "benefit": "Pure functions enable unit testing without mocking DB or UI state"
          },
          {
            "name": "vitalsStore",
            "domain": "Vital Tracking & Modification",
            "functions": [
              "updateVitals(type, value)",
              "updateGold(denomination, value)",
              "updateHope(value)",
              "updateEvasion(value)",
              "updateModifiers(stat, modifiers)",
              "updateExperiences(experiences)",
              "state: { vitals modifications, error states for failed updates }"
            ],
            "rationale": "Handles incremental updates to character resources. Manages optimistic updates and error recovery.",
            "benefit": "Can implement proper error handling and rollback logic"
          },
          {
            "name": "uiStateStore",
            "domain": "UI State & Navigation",
            "functions": [
              "setActiveTab(tab)",
              "openDiceOverlay() / closeDiceOverlay()",
              "prepareRoll(label, modifier, dice)",
              "setLastRollResult(result)",
              "state: { activeTab, isDiceOverlayOpen, activeRoll, lastRollResult }"
            ],
            "rationale": "Purely UI orchestration. Independent from character data and game logic."
          },
          {
            "name": "inventoryStore",
            "domain": "Inventory & Equipment Management",
            "functions": [
              "equipItem(itemId, slot)",
              "addItemToInventory(item)",
              "moveCard(cardId, destination)",
              "addCardToCollection(item)",
              "state: { inventory changes tracking }"
            ],
            "rationale": "Specialized operations on inventory with cascading effects (equip item -> recalc stats)"
          }
        ],
        "interaction_pattern": {
          "description": "Stores interact through subscriptions and hooks, not direct coupling",
          "example": "vitalsStore can subscribe to characterStore.character and gameLogicStore for validation. When equipment changes (inventoryStore), it triggers gameLogicStore recalculation, which updates vitals.",
          "pseudocode": {
            "equipItem": [
              "1. inventoryStore.equipItem(itemId, slot)",
              "2. optimistically update local inventory state",
              "3. persist to DB via supabase",
              "4. if success: notify gameLogicStore to recalculate",
              "5. gameLogicStore.recalculateDerivedStats() returns new vitals",
              "6. vitalsStore applies new derived vitals",
              "7. if DB fails: vitalsStore reverts optimistic update"
            ]
          }
        },
        "migration_path": [
          "Step 1: Extract pure game logic functions to /lib/gameLogic.ts",
          "Step 2: Create new stores incrementally (authStore first, as it has fewest dependencies)",
          "Step 3: Create wrapper hooks that combine store subscriptions for backward compatibility",
          "Step 4: Update components to use specific stores instead of useCharacterStore",
          "Step 5: Remove old monolithic store after all migrations complete",
          "Step 6: Add error handling to vitalsStore for failed optimistic updates"
        ]
      },
      "effort_estimate": "40-60 hours",
      "breakdown": {
        "extract_game_logic": "8-10 hours (move calculations out, write pure functions, write unit tests)",
        "create_new_stores": "12-16 hours (5 stores with proper error handling and state management)",
        "update_components": "12-16 hours (trace all useCharacterStore usage, update to use specific stores, update tests)",
        "testing": "6-10 hours (add comprehensive tests for each store in isolation, add integration tests)",
        "documentation": "2-4 hours (document store interactions, migration guide)"
      }
    },
    {
      "issue_name": "Issue 2: Zero Test Coverage",
      "severity": "CRITICAL",
      "root_cause": "No test infrastructure exists (no jest.config, no vitest.config, no __tests__ directories). The monolithic store and tight coupling between layers makes testing nearly impossible without major refactoring. Current architecture has pure functions (game calculations) mixed with side effects (DB calls), preventing isolated unit tests.",
      "impact": {
        "regression_risk": "CRITICAL - Any refactoring could silently break game logic. Armor calculations, stat modifiers, damage thresholds have zero protection.",
        "confidence": "CRITICAL - Cannot deploy with confidence. No regression detection. Bug fixes require manual QA.",
        "onboarding": "HIGH - New developers cannot validate their changes work correctly without live testing.",
        "critical_functions_unprotected": [
          "recalculateDerivedStats() (lines 290-429): Complex calculation with 4 sources of modification (base, system mods, manual mods, caps). No validation that caps are applied correctly.",
          "getSystemModifiers() (lib/utils.ts): Uses regex parsing to extract modifiers from text. Regex edge cases untested.",
          "updateVitals() (lines 797-826): Validates vitals against max/min. No test that clamping works correctly.",
          "equipItem() (lines 564-613): Complex state management with cascading effects (swap items, recalc). No test for swap logic.",
          "fetchCharacter() (lines 626-795): Data hydration and migration logic. Backward compatibility migration untested."
        ]
      },
      "reproduction_steps": [
        "Try to run `npm test` - command does not exist (only lint/build)",
        "Check package.json - no jest or vitest dependency",
        "Check for jest.config or vitest.config - do not exist",
        "Try to create a test for armor calculation - cannot import and test recalculateDerivedStats in isolation due to Zustand store dependency",
        "Attempt to test getSystemModifiers with edge case regexes - test would require mocking entire character object",
        "Try to verify that armor caps at 12 - no automated check, requires manual gameplay testing"
      ],
      "recommended_fix": {
        "testing_infrastructure": {
          "framework": "Vitest (recommended over Jest for Next.js 15)",
          "reason": "Vitest has better ESM support, faster execution, smaller config, native TypeScript support"
        },
        "setup_steps": [
          "1. Install: npm install -D vitest @vitest/ui happy-dom",
          "2. Create vitest.config.ts with Next.js support",
          "3. Create test directory structure: __tests__/unit, __tests__/integration",
          "4. Add test script: 'npm run test' and 'npm run test:watch'"
        ],
        "testing_strategy": {
          "phase_1_critical": "Unit tests for pure game logic (HIGH ROI)",
          "scope": [
            "lib/gameLogic.ts (armor calc, threshold calc, modifier aggregation) - 20-30 tests",
            "lib/utils.ts functions (getSystemModifiers, parseRegex) - 10-15 tests",
            "Data transformation logic in fetchCharacter (vitals migration, experiences parsing) - 8-10 tests"
          ],
          "estimated_time": "20-25 hours"
        },
        "testing_strategy_phase_2": "Integration tests for store actions",
        "scope_phase_2": [
          "Character loading and hydration flow - 5 tests",
          "Vital updates with validation - 6 tests",
          "Equipment changes and cascading effects - 5 tests",
          "Modifier updates triggering recalculation - 4 tests"
        ],
        "estimated_time_phase_2": "15-20 hours",
        "testing_strategy_phase_3": "Component integration tests",
        "scope_phase_3": [
          "VitalCard increment/decrement interactions - 6 tests",
          "Inventory equip/unequip flows - 4 tests",
          "Modifier sheet CRUD operations - 4 tests"
        ],
        "estimated_time_phase_3": "15-20 hours"
      },
      "critical_functions_to_test": [
        {
          "function": "recalculateDerivedStats()",
          "test_cases": [
            "Armor score calculation with equipped armor vs unarmored (should be 0 base unarmored)",
            "Armor caps at 12 per SRD (test base_score + system mods + user mods > 12)",
            "Damage threshold calculation with armor bonuses applied correctly",
            "HP max calculation from class base + item mods + user mods",
            "Stress max calculation (base 6 + mods)",
            "Armor slots capped at armor_score when recalculating",
            "HP current capped at new HP max if max decreases",
            "With empty inventory (no modifiers, no armor), verify defaults",
            "With multiple equipment pieces each providing modifiers, verify stacking",
            "Verify thresholds include armor bonus from equipped armor"
          ]
        },
        {
          "function": "getSystemModifiers(character, stat)",
          "test_cases": [
            "Structured modifiers parsed correctly (modifiers array in library_item.data)",
            "Regex fallback works for legacy text-based modifiers",
            "Multiple modifiers from same item are all extracted",
            "Unequipped items are ignored (only equipped_primary, equipped_secondary, equipped_armor counted)",
            "Edge case: item with both structured and regex should prefer structured",
            "Edge case: invalid regex in text should not crash, fallback gracefully",
            "Empty inventory returns empty array",
            "Modifier value parsing handles +/- signs correctly"
          ]
        },
        {
          "function": "updateVitals(type, value)",
          "test_cases": [
            "HP clamped between 0 and max",
            "Armor clamped between 0 and armor_score",
            "Stress clamped between 0 and stress_max",
            "DB error triggers revert of optimistic update",
            "Concurrent updates (two quick clicks) handle correctly"
          ]
        },
        {
          "function": "equipItem(itemId, slot)",
          "test_cases": [
            "Item moves to correct slot",
            "Item previously in slot moves to backpack",
            "No item in slot - just move item there",
            "Unequipping (move to backpack) works",
            "DB error for either item update should revert both changes",
            "Armor change triggers recalc (verified via subscription)"
          ]
        },
        {
          "function": "fetchCharacter(userId, characterId)",
          "test_cases": [
            "Character data loaded with relations (cards, inventory)",
            "Vitals migration: hp_current -> hit_points_current (legacy compat)",
            "Experiences migrated from string[] to Experience[] format",
            "Library items joined correctly for cards and inventory",
            "Class data fetched and loaded as class_data",
            "Damage thresholds calculated from level",
            "Non-existent character returns null gracefully",
            "Multiple concurrent fetches don't cause race conditions",
            "recalculateDerivedStats called after load to apply armor bonuses"
          ]
        }
      ],
      "effort_estimate": "50-65 hours total",
      "breakdown": {
        "setup_vitest": "3-5 hours",
        "phase_1_unit_tests": "20-25 hours",
        "phase_2_integration_tests": "15-20 hours",
        "phase_3_component_tests": "15-20 hours",
        "ci_cd_setup": "3-5 hours (GitHub Actions workflow)"
      }
    },
    {
      "issue_name": "Issue 3: Race Condition in fetchCharacter (line 794)",
      "severity": "HIGH",
      "root_cause": "Line 794: `setTimeout(() => get().recalculateDerivedStats(), 0)` is a race condition anti-pattern. The character state is set at line 791, but the recalculation is scheduled asynchronously with zero delay. Between lines 791-794, if another action modifies the character state (e.g., user equips item before recalc completes), the recalc will work with stale data or overwrite newer changes. The setTimeout(0) defers execution to next microtask loop, but async operations inside recalculateDerivedStats may not complete before setState applies.",
      "impact": {
        "data_corruption": "MEDIUM - Derived stats could be calculated against stale inventory state. If user equips item immediately after loading character, recalc might use old armor value.",
        "user_experience": "MEDIUM - Armor/HP/Stress maxes could show incorrectly briefly before correcting. Visual glitches or incorrect thresholds displayed.",
        "likelihood": "MEDIUM - Requires specific timing: character load + user action within <16ms. In fast users or testing, moderately likely."
      },
      "specific_race_condition": {
        "scenario": "Character loaded with armor equipped",
        "timeline": [
          "t=0ms: fetchCharacter() sets character state with inventory (has equipped_armor)",
          "t=0ms: setTimeout schedules recalculateDerivedStats for next tick",
          "t=2ms: User clicks equipItem() to swap armor",
          "t=2ms: equipItem() updates character.character_inventory and DB",
          "t=10ms: recalculateDerivedStats() finally executes",
          "t=10ms: recalc reads character from state (which has NEW armor from equipItem)",
          "t=10ms: BUT if equipItem's recalc hasn't completed yet, armor_score might be old",
          "Result: Armor thresholds calculated against wrong armor piece"
        ]
      },
      "data_corruption_example": {
        "scenario": "Character has no armor equipped (armor_score = 0)",
        "steps": [
          "Character loads",
          "fetchCharacter sets character with no equipped armor",
          "setTimeout schedules recalc",
          "Meanwhile, user equips Heavy Armor (base_score = 3) via equipItem()",
          "equipItem updates DB and local state",
          "equipItem calls recalculateDerivedStats()",
          "equipItem's recalc completes, armor_score = 3",
          "setTimeout's recalc fires 0-16ms later",
          "setTimeout's recalc reads current character state (which includes new armor)",
          "BUT the inventory might be stale in the closure from fetchCharacter()",
          "Potential: recalc calculates armor as 0 again, overwriting the 3"
        ]
      },
      "other_setTimeout_hacks": [
        "Line 794 only instance of setTimeout in store",
        "However, line 612 in equipItem calls get().recalculateDerivedStats() directly (correct)",
        "And line 539 in updateModifiers calls get().recalculateDerivedStats() directly (correct)",
        "So line 794 is isolated anti-pattern, but indicates developer awareness of initialization timing issues"
      ],
      "reproduction_steps": [
        "Create character with armor equipped",
        "Load character (fetchCharacter called)",
        "Immediately (within 20ms) equip different armor",
        "Check armor_score - could be incorrect if recalc()",
        "Check damage thresholds - could be wrong if calculated after equipItem but before fetchCharacter's recalc",
        "Monitor network - you might see two recalc() DB updates in quick succession"
      ],
      "recommended_fix": {
        "root_cause": "setTimeout is used to defer recalc until state is set, but this is unreliable",
        "solution_1_direct_call": {
          "approach": "Perform recalculation synchronously after state set, then persist",
          "pseudocode": [
            "// In fetchCharacter, after set():",
            "set({ character: fullCharacter, isLoading: false })",
            "// Immediately calculate (synchronously) with the new state",
            "const recalcResult = await recalculateDerivedStats()",
            "// Only update DB with final result",
            "await supabase.update(recalcResult)"
          ],
          "problem": "Store actions cannot be called within set() - circular dependency"
        },
        "solution_2_wrapper_action": {
          "approach": "Create a fetchAndInitialize wrapper that handles full flow atomically",
          "pseudocode": [
            "fetchCharacterAndInitialize: async (userId, characterId?) => {",
            "  set({ isLoading: true })",
            "  const data = await fetchCharacterData(userId, characterId)",
            "  const richData = await enrichCharacterData(data)",
            "  const character = buildCharacter(richData)",
            "  set({ character, isLoading: false })",
            "  // NOW recalc uses the character that was just set",
            "  const calculated = calculateDerivedStats(character)",
            "  // Update derived stats without race condition",
            "  set({ character: { ...character, ...calculated } })",
            "  // Persist to DB",
            "  await persistDerivedStats(character.id, calculated)",
            "}"
          ],
          "benefit": "All operations are sequential and observable within single action"
        },
        "solution_3_promise_chain": {
          "approach": "Return promise from set(), chain operations explicitly",
          "pseudocode": [
            "fetchCharacter: async (userId, characterId?) => {",
            "  // Fetch and set initial state",
            "  const fullCharacter = await assembleCharacterData(...)",
            "  set({ character: fullCharacter, isLoading: false })",
            "  // Wait for state update to complete (not guaranteed in Zustand)",
            "  // Instead, pass character to recalc directly",
            "  const recalcResult = await recalculateDerivedStatsForCharacter(fullCharacter)",
            "  // Apply result",
            "  set(s => ({ character: s.character ? { ...s.character, ...recalcResult } : null }))",
            "}"
          ],
          "benefit": "No setTimeout. Explicit control flow."
        },
        "recommended_approach": "Solution 2 (fetchCharacterAndInitialize) + additional precautions"
      },
      "additional_safeguards": [
        "Add version/timestamp to derived stats to detect stale calculations",
        "Before persisting derived stats, verify inventory hasn't changed since calculation",
        "Add assertion that armor_score <= 12 in updateVitals (catch overflow)",
        "Add test that simulates rapid equipItem + fetchCharacter sequence"
      ],
      "effort_estimate": "8-12 hours",
      "breakdown": {
        "refactor_fetchCharacter": "4-6 hours (reorganize logic, eliminate setTimeout)",
        "add_safeguards": "2-3 hours (add validation, version tracking)",
        "write_race_condition_tests": "2-3 hours (test rapid concurrent actions)"
      }
    },
    {
      "issue_name": "Issue 4: Error Recovery Missing",
      "severity": "CRITICAL",
      "root_cause": "The store uses optimistic updates (update UI immediately, then persist to DB) without error handling. When DB operations fail, the optimistic state persists, creating inconsistency between client and server. Lines 205-208 (moveCard), 457-460 (updateGold), 482-484 (updateHope), 507-510 (updateEvasion), 559-561 (updateExperiences), 605-608 (equipItem), 822-825 (updateVitals) all follow the same pattern: no error recovery. Additionally, equipItem makes multiple DB calls in sequence (lines 599-609) without transaction semantics - if second fails, first succeeds.",
      "impact": {
        "data_consistency": "CRITICAL - User sees updated values locally, but DB doesn't match. On page refresh, changes are lost.",
        "user_trust": "CRITICAL - Users see their actions succeed, then lose progress. Frustrating and confusing.",
        "cascading_failures": "HIGH - equipItem makes TWO DB updates (old item to backpack, new item to slot). If second fails, inventory is inconsistent (item in two slots).",
        "state_explosion": "HIGH - Over time, stale optimistic updates accumulate. Next sync is confused.",
        "specific_scenarios": [
          "User marks armor slot down. Shows visually as reduced. DB update fails due to network. User refreshes - armor is back to full. User's action lost.",
          "User equips new sword. Optimistic update shows new sword. DB update fails on new sword INSERT (duplicate key). User refreshes - old sword is still equipped. Confusion.",
          "User has 5 stress, tries to add more. Optimistic update shows 6. DB fails. User refreshes - still at 5. Seems like their click didn't work."
        ]
      },
      "root_cause_analysis": {
        "pattern_observed": "All async DB operations follow same pattern",
        "code_example": "updateGold (lines 431-461)",
        "flow": [
          "1. Get current state",
          "2. Calculate new value",
          "3. Optimistically update state (set)",
          "4. Launch async DB update",
          "5. If error: console.error, but state remains changed",
          "6. No rollback, no retry, no error notification to user"
        ]
      },
      "reproduction_steps": [
        "Open DevTools network tab",
        "Set network to 'Offline'",
        "Open character sheet",
        "Try to decrease armor",
        "See armor value decrease visually",
        "Refresh page",
        "Armor is back to original value (optimistic update lost)",
        "User sees their action failed silently",
        "Repeat with gold, hope, evasion - same issue",
        "Test equipItem specifically:",
        "  - Go offline",
        "  - Try to equip sword",
        "  - See sword equip visually",
        "  - Check DB - sword not actually equipped",
        "  - Refresh - old sword still equipped"
      ],
      "data_corruption_examples": {
        "example_1": {
          "scenario": "Equipment swap fails partially",
          "steps": [
            "User has Sword A equipped, Sword B in backpack",
            "Clicks to swap (equip Sword B)",
            "equipItem logic:",
            "  - Find Sword B in inventory",
            "  - Sword A -> backpack (DB call succeeds)",
            "  - Sword B -> equipped (DB call fails)",
            "Client state: Sword B equipped, Sword A in backpack",
            "Server state: Sword A in backpack, Sword B still unequipped",
            "On refresh: Sword A is there, Sword B is there, but Sword A is showing as in backpack when it's actually equipped"
          ]
        },
        "example_2": {
          "scenario": "Concurrent operations during error state",
          "steps": [
            "User reduces armor to 2 (optimistic), DB fails",
            "User tries to reduce armor to 1 (optimistic), DB fails",
            "User tries to increase armor to 3 (optimistic), DB succeeds",
            "Client shows 3, server shows original value",
            "Next action uses wrong armor_score for recalculation"
          ]
        }
      },
      "operations_lacking_recovery": [
        {
          "function": "moveCard",
          "line": "205-208",
          "risk": "Card location out of sync. Might appear in wrong tab.",
          "affected_count": "All character cards (could be 30+)"
        },
        {
          "function": "updateGold",
          "line": "457-460",
          "risk": "User loses gold entry. Accounting is wrong.",
          "affected_count": "All gold denominations (3 values)"
        },
        {
          "function": "updateHope",
          "line": "482-484",
          "risk": "Hope value out of sync. Affects rolls.",
          "affected_count": "Single value, high impact"
        },
        {
          "function": "updateEvasion",
          "line": "507-510",
          "risk": "Evasion out of sync. Affects all rolls.",
          "affected_count": "Single value, high impact"
        },
        {
          "function": "updateModifiers",
          "line": "533-536",
          "risk": "Modifiers lost. Bonus stats disappear.",
          "affected_count": "Can be many per character"
        },
        {
          "function": "updateExperiences",
          "line": "559-561",
          "risk": "Experience tracking lost.",
          "affected_count": "Can be many"
        },
        {
          "function": "equipItem",
          "line": "605-608",
          "risk": "Item equipped in UI but not on server. Multiple DB calls with no atomicity.",
          "affected_count": "3 inventory locations per action"
        },
        {
          "function": "updateVitals",
          "line": "822-825",
          "risk": "HP/Armor/Stress out of sync. Critical gameplay impact.",
          "affected_count": "Used constantly, highest failure impact"
        }
      ],
      "recommended_fix": {
        "strategy": "Implement pessimistic updates with rollback on error (preferred) or optimistic with retry",
        "approach_1_pessimistic_updates": {
          "description": "Wait for DB to succeed before updating UI. No rollback needed.",
          "pros": ["Simple to implement", "No data inconsistency", "Handles concurrent updates easily"],
          "cons": ["UI lag (user sees delay)", "More user input waiting", "Not modern UX"],
          "implementation": [
            "// updateVitals pessimistic version",
            "updateVitals: async (type, value) => {",
            "  const state = get()",
            "  if (!state.character) return",
            "  ",
            "  const newVitals = { ...state.character.vitals }",
            "  const actualValue = clampVital(type, value, newVitals)",
            "  const updatedVitals = { ...newVitals, [type]: actualValue }",
            "  ",
            "  // Try DB first, no optimistic update yet",
            "  const supabase = createClient()",
            "  try {",
            "    const { error } = await supabase",
            "      .from('characters')",
            "      .update({ vitals: updatedVitals })",
            "      .eq('id', state.character.id)",
            "    ",
            "    if (error) throw error",
            "    ",
            "    // Only update UI after DB succeeds",
            "    set(s => ({",
            "      character: s.character ? { ...s.character, vitals: updatedVitals } : null",
            "    }))",
            "  } catch (error) {",
            "    console.error('Failed to update vitals:', error)",
            "    // Notify user via toast",
            "    showErrorToast(`Failed to update ${type}. Your change was not saved.`)",
            "    // UI never changed, so no rollback needed",
            "  }",
            "}"
          ]
        },
        "approach_2_optimistic_with_rollback": {
          "description": "Update UI immediately, but rollback on error. More modern UX.",
          "pros": ["Instant feedback to user", "Better UX experience", "Works with slow connections"],
          "cons": ["Need to store previous state", "Complex rollback logic", "Visual flicker on rollback"],
          "implementation": [
            "// updateVitals optimistic version with rollback",
            "updateVitals: async (type, value) => {",
            "  const state = get()",
            "  if (!state.character) return",
            "  ",
            "  // Store previous state for rollback",
            "  const previousVitals = state.character.vitals",
            "  const previousCharacter = state.character",
            "  ",
            "  const newVitals = { ...previousVitals }",
            "  const actualValue = clampVital(type, value, newVitals)",
            "  const updatedVitals = { ...newVitals, [type]: actualValue }",
            "  ",
            "  // Optimistically update UI",
            "  set(s => ({",
            "    character: s.character ? { ...s.character, vitals: updatedVitals } : null",
            "  }))",
            "  ",
            "  // Persist to DB",
            "  const supabase = createClient()",
            "  try {",
            "    const { error } = await supabase",
            "      .from('characters')",
            "      .update({ vitals: updatedVitals })",
            "      .eq('id', state.character.id)",
            "    ",
            "    if (error) throw error",
            "    // Success - state is already updated",
            "  } catch (error) {",
            "    console.error('Failed to update vitals:', error)",
            "    // Rollback UI to previous state",
            "    set(s => ({",
            "      character: s.character ? { ...s.character, vitals: previousVitals } : null",
            "    }))",
            "    // Notify user",
            "    showErrorToast(`Failed to save ${type}. Your change was reverted.`)",
            "  }",
            "}"
          ]
        },
        "approach_3_optimistic_with_queue": {
          "description": "Queue failed updates for retry with exponential backoff",
          "use_case": "For users with unreliable connections (mobile)",
          "complexity": "HIGH - need persistence of failed operations"
        },
        "approach_4_atomic_operations_for_multi_step": {
          "description": "For equipItem which does 2 DB updates, use transactions or sequence carefully",
          "implementation": [
            "// equipItem with atomic swap",
            "equipItem: async (itemId, slot) => {",
            "  const state = get()",
            "  if (!state.character) return",
            "  ",
            "  const inventory = [...(state.character.character_inventory || [])]",
            "  const itemIndex = inventory.findIndex(i => i.id === itemId)",
            "  if (itemIndex === -1) return",
            "  ",
            "  const previousInventory = [...inventory] // For rollback",
            "  const itemToEquip = { ...inventory[itemIndex] }",
            "  const updates = []",
            "  ",
            "  if (slot !== 'backpack') {",
            "    const existingItemIndex = inventory.findIndex(i => i.location === slot)",
            "    if (existingItemIndex !== -1) {",
            "      inventory[existingItemIndex] = { ...inventory[existingItemIndex], location: 'backpack' }",
            "      updates.push({ id: inventory[existingItemIndex].id, location: 'backpack' })",
            "    }",
            "  }",
            "  ",
            "  itemToEquip.location = slot",
            "  inventory[itemIndex] = itemToEquip",
            "  updates.push({ id: itemToEquip.id, location: slot })",
            "  ",
            "  // Optimistically update",
            "  set(s => ({",
            "    character: s.character ? { ...s.character, character_inventory: inventory } : null",
            "  }))",
            "  ",
            "  // Persist all updates (could batch into single request)",
            "  const supabase = createClient()",
            "  try {",
            "    // Ideally use a single transaction or batch request",
            "    for (const update of updates) {",
            "      const { error } = await supabase",
            "        .from('character_inventory')",
            "        .update({ location: update.location })",
            "        .eq('id', update.id)",
            "      if (error) throw error",
            "    }",
            "    ",
            "    // Success - recalculate",
            "    await get().recalculateDerivedStats()",
            "  } catch (error) {",
            "    // Rollback",
            "    set(s => ({",
            "      character: s.character ? { ...s.character, character_inventory: previousInventory } : null",
            "    }))",
            "    showErrorToast('Failed to equip item. Change reverted.')",
            "  }",
            "}"
          ]
        },
        "error_notification_strategy": [
          "Install toast library (e.g., react-hot-toast or sonner)",
          "Show clear error messages to user: 'Failed to save armor. Please try again.'",
          "Don't use console.error alone - users won't see it",
          "Provide retry button for critical operations",
          "Track error count - if same operation fails 3x, suggest refresh or report bug"
        ]
      },
      "minimal_implementation": {
        "start_with": "updateVitals (most critical, used constantly)",
        "add_error_recovery_pattern_to": [
          "updateVitals - ASAP (high usage)",
          "equipItem - next (complex, multiple DB calls)",
          "updateModifiers -> recalculate - next (affects all stats)",
          "updateGold, updateHope, updateEvasion - later (lower usage)",
          "moveCard, addCardToCollection - last (UI-only operations)"
        ]
      },
      "effort_estimate": "30-40 hours",
      "breakdown": {
        "install_error_ui_library": "1-2 hours",
        "implement_rollback_pattern_updateVitals": "4-6 hours",
        "implement_rollback_pattern_equipItem": "5-7 hours (multi-step complexity)",
        "implement_rollback_pattern_other_functions": "10-12 hours",
        "add_retry_logic": "3-5 hours",
        "write_error_recovery_tests": "5-8 hours",
        "update_ui_for_error_states": "2-3 hours"
      }
    }
  ]
}
